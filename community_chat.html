<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TeamGalaxy â€” Chat (bg + corrected footer)</title>

  <!-- fontawesome (kept for potential future use) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css "/>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/11.9.0/firebase-app-compat.js "></script>
  <script src="https://www.gstatic.com/firebasejs/11.9.0/firebase-auth-compat.js "></script>
  <script src="https://www.gstatic.com/firebasejs/11.9.0/firebase-firestore-compat.js "></script>

  <style>
    :root{
      --bg-image: url('https://dl.dropboxusercontent.com/scl/fi/7vp6uxrkls3o0e4325kir/IMG_20251105_161000.png?rlkey=uh7nftac6l80vtlvqjnm6kwfq&st=qvii34oe&dl=0');
      --bg-overlay: rgba(10,8,24,0.45);
      --accent-1: #8a7cff;
      --accent-2: #d66efd;
    }

    html,body { height:100%; }
    *,*::before,*::after { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      font-family: 'Segoe UI', system-ui, Roboto, Arial, sans-serif;
      color: #e0e0ff;
      background: linear-gradient(135deg,#0f0c29,#302b63,#24243e);
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -2;
      background-image: var(--bg-image);
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      filter: none;
    }
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      z-index: -1;
      background: var(--bg-overlay);
      pointer-events: none;
    }

  /* ---------------------------------- */
  /* 1. FONT DEFINITION (@font-face Rule) */
  /* ---------------------------------- */
  @font-face {
      font-family: 'Sefa Regular';
      src: url('assets/fonts/Sefa-Regular.woff2') format('woff2'),
           url('assets/fonts/Sefa-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
  }

    .site-header, .site-footer {
      width: 100%;
      left: 0;
      right: 0;
      box-sizing: border-box;
      background: rgba(10,10,35,0.95);
      z-index: 40;
    }

    .site-header .container-inner,
    .site-footer .container-inner {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0.85rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      box-sizing: border-box;
    }

    .logo { font-weight:700; background: linear-gradient(45deg,var(--accent-1),var(--accent-2)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; font-size:1.35rem; }
    .profile-photo { width:44px; height:44px; border-radius:50%; overflow:hidden; border:2px solid var(--accent-1); display:flex; align-items:center; justify-content:center; background: linear-gradient(45deg,#6a5af9,#d66efd); color:#fff; font-weight:700; }

    .app-wrap { width:100%; display:flex; justify-content:center; flex:1 0 auto; }
    .container {
      width:100%;
      max-width:1200px;
      padding: 1rem;
      display:flex;
      flex-direction:column;
      gap:1rem;
      box-sizing:border-box;
      flex: 1 0 auto;
    }

    .chat-container {
      display:flex;
      flex-direction:column;
      background: rgba(20,20,40,0.56);
      border-radius: 14px;
      border: 1px solid rgba(90,79,207,0.12);
      overflow: hidden;
      box-shadow: 0 15px 35px rgba(0,0,0,0.35);
      width:100%;
      min-height:480px;
      backdrop-filter: blur(6px);
    }

    .messages-area {
      flex:1;
      padding:1.25rem;
      overflow-y:auto;
      display:flex;
      flex-direction:column;
      gap:1rem;
      align-items: stretch;
      scroll-behavior:smooth;
      width:100%;
    }

    .message-card {
      background: rgba(30,30,50,0.64);
      padding:1rem;
      border-radius:12px;
      border:1px solid rgba(68,70,111,0.12);
      display:flex;
      flex-direction:column;
      gap:0.5rem;
      width:100%;
      box-sizing:border-box;
      word-break:break-word;
    }

    .message-header { display:flex; align-items:center; gap:0.75rem; }
    .avatar { width:40px; height:40px; border-radius:50%; flex-shrink:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(45deg,#6a5af9,#d66efd); color:#fff; font-weight:700; border:2px solid rgba(138,124,255,0.25); overflow:hidden; }
    .avatar img{ width:100%; height:100%; object-fit:cover; display:block; }
    .user-info { display:flex; flex-direction:column; min-width:0; }
    .username { font-weight:600; color:var(--accent-1); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .timestamp { font-size:.8rem; color:#a0a0d0; white-space:nowrap; }

    .reply-preview { background:rgba(255,255,255,0.03); padding:.5rem; border-left:3px solid rgba(138,124,255,0.4); border-radius:6px; font-size:.95rem; color:#cbd6ff; }
    .message-content { white-space:pre-wrap; color:#e7e7ff; }

    .message-actions { display:flex; gap:.5rem; align-items:center; margin-top:.4rem; }
    .btn-ghost { background:transparent; border:1px solid rgba(255,255,255,0.03); color:#cfe6ff; padding:.35rem .6rem; border-radius:8px; cursor:pointer; }
    .btn-ghost:hover { border-color:var(--accent-1); color:#fff; }
    .heart-btn { display:inline-flex; align-items:center; gap:.35rem; }
    .heart-count { font-weight:700; color:#ff7b9b; }

    .typing-indicator { padding:.45rem 0; color:#a8caff; min-height:20px; }
    .reply-container { padding:0 0.75rem; }
    .reply-preview { display:block; background:rgba(255,255,255,0.03); padding:.6rem; border-left:3px solid rgba(138,124,255,0.6); border-radius:6px; color:#cbe3ff; }

    .input-area { padding:1rem; display:flex; gap:.6rem; border-top:1px solid rgba(90,79,207,0.08); align-items:flex-end; background:transparent; }
    .message-input { flex:1; padding:.9rem; border-radius:10px; border:1px solid rgba(68,70,111,0.12); background: rgba(12,12,24,0.28); color:#eef; font-size:1rem; outline:none; }
    .message-input:focus { border-color:var(--accent-1); box-shadow:0 0 10px rgba(138,124,255,0.12); }
    .send-button { padding:.9rem 1.2rem; border-radius:10px; border:none; background:linear-gradient(45deg,#6a5af9,#d66efd); color:white; font-weight:700; cursor:pointer; }
    .send-button:disabled { opacity:.5; cursor:not-allowed; }

    .footer-content {
      width:100%;
      display:flex;
      gap:1.5rem;
      align-items:start;
      box-sizing:border-box;
      padding: .9rem 1rem;
    }
    .footer-left, .footer-right {
      flex: 1 1 50%;
      min-width: 0;
      box-sizing: border-box;
    }
    .footer-left { padding-right: .5rem; }
    .footer-right { padding-left: .5rem; display:flex; flex-direction:column; gap:.75rem; }

    .footer-about-title { font-size:1.05rem; color:var(--accent-1); margin-bottom:.6rem; font-weight:600; }
    .footer-about-text { color:#a0a0d0; line-height:1.6; font-size:.9rem; }
    .footer-links { display:flex; flex-direction:column; gap:.6rem; }
    .footer-links a { color:#a0a0d0; text-decoration:none; transition:color .15s; }
    .footer-links a:hover { color:var(--accent-1); text-decoration:underline; }

    .rocket-frame { margin-top: .5rem; padding: .8rem; border:2px solid #5a4fcf; border-radius:12px; background:rgba(20,20,40,0.35); overflow:hidden; max-width:420px; width:100%; box-sizing:border-box; }
    .rocket-text { font-size: clamp(1.05rem, 3vw, 1.4rem); font-weight:bold; background:linear-gradient(45deg,var(--accent-1),var(--accent-2),var(--accent-1)); background-size:200% auto; -webkit-background-clip:text; -webkit-text-fill-color:transparent; animation: shimmer 3s linear infinite; text-align:center; line-height:1.2; }
    @keyframes shimmer { 0% { background-position: -200% center; } 100% { background-position: 200% center; } }

    @media (max-width:768px){
      .footer-content { flex-direction: column; padding:.75rem; gap: .75rem; }
      .footer-left, .footer-right { flex: none; width:100%; padding: 0; }
      .container { padding: .75rem; }
      .site-header .container-inner, .site-footer .container-inner { padding: .75rem .9rem; }
    }

    /* Loading overlay */
    #loadingOverlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(4,10,20,0.85), rgba(8,12,25,0.85));
      backdrop-filter: blur(6px);
      color: #dbeeff;
      flex-direction: column;
      gap: 12px;
      padding: 24px;
    }
    #loadingOverlay .overlay-card {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      max-width: 720px;
      text-align: center;
    }
    #loadingOverlay .overlay-title { font-size: 1.4rem; font-weight:700; color:#fff; }
    #loadingOverlay .overlay-sub { font-size: 1rem; color:#cfeaff; opacity:0.95; }
    .dots { display:inline-flex; gap:8px; align-items:center; padding-top:4px; }
    .dot { width:10px; height:10px; border-radius:50%; background:linear-gradient(90deg,#64c2ff,#8a7cff); box-shadow: 0 0 8px rgba(100,194,255,0.18); transform: translateY(0); animation: dotUp 1.1s infinite ease-in-out; opacity:0.95; }
    .dot.d2 { animation-delay: 0.15s; } .dot.d3 { animation-delay:0.3s; }
    @keyframes dotUp { 0%{transform:translateY(0);opacity:0.5;}40%{transform:translateY(-8px);opacity:1;}100%{transform:translateY(0);opacity:0.5;} }
    #loadingOverlay.hidden { display:none !important; }

/* Footer should expand fully with black background */
.site-footer {
  width: 100%;
  background: rgba(10,10,35,0.95);  /* full background */
  padding: 0; /* weâ€™ll handle padding inside content */
  box-sizing: border-box;
}

/* Remove background and fixed padding from inner wrapper */
.site-footer .container-inner {
  background: transparent;
  padding: 0; /* let real footer-content control spacing */
  width: 100%;
}

/* Make footer-content decide the height and spacing */
.footer-content {
  width: 100%;
  display: flex;
  gap: 1.5rem;
  align-items: flex-start;
  padding: 1.2rem 1rem;   /* increased padding so height grows properly */
  box-sizing: border-box;
}

/* Mobile fix â€” ensure vertical layout expands naturally */
@media (max-width: 768px) {
  .footer-content {
    flex-direction: column;
    padding: 1.2rem 1rem;
    gap: 1.2rem;
  }
}
  </style>
</head>  
<body>
  <!-- Loading overlay -->
  <div id="loadingOverlay" class="hidden" role="status" aria-live="polite">
    <div class="overlay-card">
      <div class="overlay-title">Connecting to the cosmic chatâ€¦</div>
      <div class="overlay-sub">Fetching live messages and preparing the community space â€” this helps keep the feed fresh and safe.</div>
      <div class="dots" aria-hidden="true">
        <span class="dot d1"></span>
        <span class="dot d2"></span>
        <span class="dot d3"></span>
      </div>
      <div style="font-size:.9rem;color:rgba(200,220,255,0.75);max-width:640px">
        Tip: if loading takes longer than a few seconds check your connection or try refreshing. Messages are synced in real time.
      </div>
    </div>
  </div>

  <header class="site-header" role="banner">
    <div class="container-inner">

        <div   
        class="logo"   
        onclick="window.location.href='dashboard.html'"   
        style="  
            cursor: pointer;  font-family: 'Sefa Regular', sans-serif;   
        font-size: 2.5em;   
        font-weight: bold;  
        color: #ccf381; /* Neon color */  
        letter-spacing: 3px;  
    "  
>  
    GalaxyWeb  
</div>
      <div class="profile-photo" id="header-avatar" aria-hidden="false">U</div>
    </div>
  </header>

  <div class="app-wrap">
    <div class="container">
      <main class="chat-container" role="main">
        <div id="messages-area" class="messages-area">
          <div style="text-align:center;color:#a0a0d0;padding:2rem;">Loading chat...</div>
        </div>

        <div id="typing-indicator" class="typing-indicator" aria-live="polite"></div>

        <div id="reply-preview-wrap" class="reply-container" style="display:none" aria-hidden="true">
          <div class="reply-preview" id="reply-preview"></div>
        </div>

        <div class="input-area">
          <input id="message-input" class="message-input" placeholder="Write your message..." maxlength="1000" autocomplete="off" />
          <button id="send-button" class="send-button" disabled>Send</button>
        </div>
      </main>
    </div>
  </div>

  <footer class="site-footer" role="contentinfo" aria-label="Site footer">
    <div class="container-inner">
      <div class="footer-content">
        <div class="footer-left">
          <div>
            <div class="footer-about-title">About TeamGalaxy</div>
            <div class="footer-about-text">
              TeamGalaxy is an innovative gaming and creative community, united by passion and the spirit of collaboration. We host tournaments, share design ideas, and grow talents together â€” join now to explore the Galaxy!
            </div>
          </div>
        </div>

        <div class="footer-right">
          <div class="footer-links">
            <a href="legal/privacy_policy.html">Privacy Policy</a>
            <a href="legal/terms_and_conditions.html">Terms & Conditions</a>
            <a href="about_us.html">About</a>
          </div>

          <div class="rocket-frame" aria-hidden="true" style="margin-top:12px;">
            <div class="rocket-text">ðŸš€ ROCKET ðŸš€</div>
          </div>
        </div>
      </div>
    </div>
  </footer>

  <script>
    // FIREBASE CONFIG (unchanged)
    const firebaseConfig = {
      apiKey: "AIzaSyD0Yv_bQjxi2_kjzPR4XHOlaB7Sb6NRVUc",
      authDomain: "teamgalaxy-77344.firebaseapp.com",
      projectId: "teamgalaxy-77344",
      storageBucket: "teamgalaxy-77344.firebasestorage.app",
      messagingSenderId: "770256225320",
      appId: "1:770256225320:web:5a363ebd757de6cde3a11d",
      measurementId: "G-6C2W9NSNCH"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // DOM refs
    const messagesArea = document.getElementById('messages-area');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const headerAvatar = document.getElementById('header-avatar');
    const typingIndicator = document.getElementById('typing-indicator');
    const replyPreviewWrap = document.getElementById('reply-preview-wrap');
    const replyPreview = document.getElementById('reply-preview');
    const loadingOverlay = document.getElementById('loadingOverlay');

    function showLoadingOverlay(title, sub) {
      if (title) {
        const t = loadingOverlay.querySelector('.overlay-title');
        if (t) t.textContent = title;
      }
      if (sub) {
        const s = loadingOverlay.querySelector('.overlay-sub');
        if (s) s.textContent = sub;
      }
      loadingOverlay.classList.remove('hidden');
    }
    function hideLoadingOverlay() {
      loadingOverlay.classList.add('hidden');
    }

    showLoadingOverlay('Connecting to the chatâ€¦', 'Syncing messages and preparing the community feed');

    // State
    let unsubscribeMessages = null;
    let unsubscribeTyping = null;
    let currentProfile = null; // { uid, name, photoUrl, slug? }
    let typingTimeout = null;
    let localTyping = false;
    let replyTo = null;
    let userHeartsSet = new Set();
    const MAX_SNIPPET = 120;
    let latestSnapshotDocs = {};

    // Spam / rate-limit state (per user; persisted in usersPrivate.spamControl)
    let spamState = {
      violationCount: 0,
      muteUntil: 0, // ms since epoch
      lastMessageText: '',
      lastMessageRepeatCount: 0
    };
    // Local only recent messages (last 60s)
    let messageHistory = []; // { ts, len, text }

    function escapeHtml(s=''){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,"&#039;"); }
    function formatTime(ts){
      if(!ts) return 'Just now';
      try{
        const d = ts.toDate ? ts.toDate() : new Date(ts);
        return d.toLocaleString('en-IN',{hour:'2-digit',minute:'2-digit',day:'2-digit',month:'short'});
      }catch(e){return 'Just now'}
    }
    function snippet(s,n=MAX_SNIPPET){ if(!s) return ''; return s.length>n? s.slice(0,n)+'â€¦': s; }

    function getRemainingMuteMs() {
      if (!spamState.muteUntil) return 0;
      const diff = spamState.muteUntil - Date.now();
      return diff > 0 ? diff : 0;
    }

    async function persistSpamState() {
      const user = auth.currentUser;
      if (!user) return;
      const payload = {
        spamControl: {
          violationCount: spamState.violationCount || 0,
          muteUntil: spamState.muteUntil ? new Date(spamState.muteUntil) : null,
          lastMessageText: spamState.lastMessageText || '',
          lastMessageRepeatCount: spamState.lastMessageRepeatCount || 0,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }
      };
      try {
        await db.collection('usersPrivate').doc(user.uid).set(payload, { merge: true });
      } catch (e) {
        console.warn('persistSpamState error', e);
      }
    }

    async function logSpamEvent(reason, meta, muteMs, violationIndex) {
      const user = auth.currentUser;
      if (!user) return;
      try {
        const ref = db.collection('usersPrivate')
                      .doc(user.uid)
                      .collection('spamEvents');

        // Log the violation event
        await ref.add({
          reason: reason,
          meta: meta || {},
          violationIndex: violationIndex,
          muteMs: muteMs || 0,
          at: firebase.firestore.FieldValue.serverTimestamp()
        });
      } catch (e) {
        console.warn('logSpamEvent error', e);
      }
    }

    async function handleSpamViolation(reason, meta) {
      // Exponential backoff penalties: 1st warn, then 1m, 10m, 60m
      const penalties = [0, 60 * 1000, 10 * 60 * 1000, 60 * 60 * 1000];
      let vc = spamState.violationCount || 0;
      vc += 1;
      spamState.violationCount = vc;

      const idx = Math.min(vc - 1, penalties.length - 1);
      const muteMs = penalties[idx];
      if (muteMs > 0) {
        spamState.muteUntil = Date.now() + muteMs;
      }

      await persistSpamState();
      await logSpamEvent(reason, meta, muteMs, vc);

      if (muteMs === 0) {
        alert('Warning: Your recent activity looks like spam. Please slow down or you may be temporarily muted.');
      } else {
        const seconds = Math.ceil(muteMs / 1000);
        let msg;
        if (seconds < 60) {
          msg = `You have been muted for ${seconds} seconds due to spam-like activity. Please wait before sending more messages.`;
        } else {
          const mins = Math.ceil(seconds / 60);
          msg = `You have been muted for about ${mins} minute(s) due to repeated spam-like activity. Please wait before sending more messages.`;
        }
        alert(msg);
      }
    }

    // Returns true if message allowed, false if blocked
    async function checkAndHandleRateLimit(text) {
      const trimmed = (text || '').trim();
      if (!trimmed) return false;

      const now = Date.now();

      // Existing mute check
      const remaining = getRemainingMuteMs();
      if (remaining > 0) {
        const secs = Math.ceil(remaining / 1000);
        const mins = secs >= 60 ? Math.ceil(secs / 60) : 0;
        if (mins > 0) {
          alert(`You are temporarily muted. Please wait about ${mins} minute(s) before sending more messages.`);
        } else {
          alert(`You are temporarily muted. Please wait ${secs} second(s) before sending more messages.`);
        }
        return false;
      }

      // Clean up history (keep only last 60s)
      messageHistory = messageHistory.filter(m => now - m.ts <= 60000);

      const len = trimmed.length;

      // 4. Character Flood rule: >500 chars, 2 such msgs in 1 minute
      const longMsgsLastMin = messageHistory.filter(m => m.len > 500).length;
      if (len > 500 && longMsgsLastMin >= 1) {
        await handleSpamViolation('char_flood', {
          type: 'char_flood',
          textLength: len,
          longMessagesLastMinute: longMsgsLastMin + 1
        });
        alert('Your message is too long and you have already sent a large message recently. Please reduce length to avoid spam.');
        return false;
      }

      // 2. Repetition rule: same message 3 times consecutively
      let repeatCount = 1;
      if (trimmed && trimmed === spamState.lastMessageText) {
        repeatCount = (spamState.lastMessageRepeatCount || 1) + 1;
      }
      if (repeatCount >= 3) {
        await handleSpamViolation('repetition', {
          type: 'repetition',
          textSample: trimmed.slice(0, 200),
          repeatCount: repeatCount
        });
        alert('You are sending the same message repeatedly. Please avoid copy-paste spam.');
        return false;
      }

      // 1. Velocity / Frequency rule: more than 5 messages in 5 seconds
      const recent5s = messageHistory.filter(m => now - m.ts <= 5000).length;
      if (recent5s + 1 > 5) {
        await handleSpamViolation('velocity', {
          type: 'velocity',
          messagesLast5sBefore: recent5s,
          messagesLast5sAfter: recent5s + 1
        });
        alert('You are sending messages too quickly. Please slow down.');
        return false;
      }

      // If we reach here, message is allowed â€” update local spam counters
      spamState.lastMessageText = trimmed;
      spamState.lastMessageRepeatCount = repeatCount;
      messageHistory.push({ ts: now, len, text: trimmed });

      // no need to persist after every allowed message; only on violation / mute change
      return true;
    }

    function buildMessageElement(data, id){
      const card = document.createElement('div'); card.className = 'message-card'; card.dataset.docId = id;
      const header = document.createElement('div'); header.className = 'message-header';
      const avatarWrap = document.createElement('div'); avatarWrap.className = 'avatar';
      const initials = (data.authorName || 'U').charAt(0).toUpperCase();

      // Prefer current user's auth/profile photo for their own messages,
      // fallback to stored authorPhotoUrl for everyone else.
      let photoUrlToUse = '';
      try {
        const isAuthorCurrentUser = data.authorUid && currentProfile && (data.authorUid === currentProfile.uid);
        if (isAuthorCurrentUser && currentProfile && currentProfile.photoUrl) {
          photoUrlToUse = currentProfile.photoUrl;
        } else if (data.authorPhotoUrl) {
          photoUrlToUse = data.authorPhotoUrl;
        } else {
          photoUrlToUse = '';
        }
      } catch(e) { photoUrlToUse = data.authorPhotoUrl || ''; }

      if(photoUrlToUse){
        const img = document.createElement('img'); img.src = photoUrlToUse; img.alt = (data.authorName || 'Avatar').slice(0,20);
        img.onerror = ()=>{ if(img.parentElement) img.parentElement.removeChild(img); avatarWrap.textContent = initials; };
        avatarWrap.appendChild(img);
      } else { avatarWrap.textContent = initials; }

      const userInfo = document.createElement('div'); userInfo.className = 'user-info';
      const uname = document.createElement('div'); uname.className = 'username'; uname.innerHTML = escapeHtml(data.authorName || 'Anonymous');
      const ts = document.createElement('div'); ts.className = 'timestamp'; ts.textContent = formatTime(data.timestamp);
      userInfo.appendChild(uname); userInfo.appendChild(ts);
      header.appendChild(avatarWrap); header.appendChild(userInfo);

      if(data.replyToAuthorName || data.replyToSnippet){
        const rp = document.createElement('div'); rp.className = 'reply-preview'; rp.style.fontSize = '.9rem';
        rp.innerHTML = `<strong style="color:#cbe3ff">${escapeHtml(data.replyToAuthorName || '')}</strong>: ${escapeHtml((data.replyToSnippet || '').slice(0,MAX_SNIPPET))}`;
        card.appendChild(header); card.appendChild(rp);
      } else {
        card.appendChild(header);
      }

      const content = document.createElement('div'); content.className = 'message-content'; content.innerHTML = escapeHtml(data.text || '');
      card.appendChild(content);

      const actions = document.createElement('div'); actions.className = 'message-actions';
      const replyBtn = document.createElement('button'); replyBtn.className = 'btn-ghost'; replyBtn.type = 'button'; replyBtn.textContent = 'Reply';
      replyBtn.addEventListener('click', ()=> setReplyTo({ id, authorName: data.authorName || 'Anonymous', snippet: snippet(data.text || '') }));
      const heartBtn = document.createElement('button'); heartBtn.className = 'btn-ghost heart-btn'; heartBtn.type = 'button';
      const heartIcon = document.createElement('span'); heartIcon.innerHTML = userHeartsSet.has(id) ? 'â¤ï¸' : 'ðŸ¤';
      const heartCount = document.createElement('span'); heartCount.className = 'heart-count'; heartCount.textContent = (data.heartsCount || 0);
      heartBtn.appendChild(heartIcon); heartBtn.appendChild(heartCount);
      heartBtn.addEventListener('click', async ()=> toggleHeart(id));
      actions.appendChild(replyBtn); actions.appendChild(heartBtn);
      card.appendChild(actions);
      return card;
    }

    function renderMessagesFromSnapshot(snapshot){
      latestSnapshotDocs = {};
      snapshot.docs.forEach(d => latestSnapshotDocs[d.id] = d.data());
      messagesArea.innerHTML = '';
      if(!snapshot.docs.length){
        messagesArea.innerHTML = '<div style="text-align:center;color:#a0a0d0;padding:2rem;">No messages yet. Say hi ðŸ‘‹</div>';
        hideLoadingOverlay();
        return;
      }
      snapshot.docs.forEach(d => {
        const el = buildMessageElement(d.data(), d.id);
        messagesArea.appendChild(el);
      });
      messagesArea.scrollTop = messagesArea.scrollHeight;
      hideLoadingOverlay();
    }

    async function sendMessage(){
      const rawText = messageInput.value;
      const text = rawText.trim();
      if(!text) return;
      sendButton.disabled = true;
      try{
        const user = auth.currentUser; if(!user) throw new Error('Not signed in');

        // Spam & rate-limit checks BEFORE doing any Firestore writes
        const allowed = await checkAndHandleRateLimit(text);
        if (!allowed) {
          return;
        }

        // try to read user's private doc for optional display overrides
        let pd = {};
        try {
          const privateDoc = await db.collection('usersPrivate').doc(user.uid).get();
          if(privateDoc.exists) pd = privateDoc.data() || {};
        } catch(e) {
          console.warn('private doc fetch failed', e);
        }

        // Build message using UID as canonical author reference
        // IMPORTANT: authorPhotoUrl now prefers Google/Firebase auth photo
        const msg = {
          text,
          authorUid: user.uid,
          authorName: pd.name || pd.displayName || user.displayName || (user.email ? user.email.split('@')[0] : 'Anonymous'),
          authorPhotoUrl: user.photoURL || pd.profilePhotoUrl || pd.photoUrl || '',
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          visibility: true,
          likes: 0,
          heartsCount: 0
        };

        if(replyTo && replyTo.id){
          msg.replyToId = replyTo.id;
          msg.replyToAuthorName = replyTo.authorName || (latestSnapshotDocs[replyTo.id] && latestSnapshotDocs[replyTo.id].authorName) || 'Unknown';
          msg.replyToSnippet = replyTo.snippet || (latestSnapshotDocs[replyTo.id] && snippet(latestSnapshotDocs[replyTo.id].text || '')) || '';
        }

        await db.collection('communityMessages').add(msg);
        messageInput.value = '';
        clearReply();
        stopTyping();
      }catch(err){
        console.error('send error',err);
        alert('Send failed: ' + (err.message || 'unknown'));
      }finally{
        sendButton.disabled = false;
      }
    }

    async function toggleHeart(messageId){
      const user = auth.currentUser;
      if(!user){ alert('Sign in to heart'); return; }
      const uid = user.uid;
      const heartDocId = `${messageId}_${uid}`;
      const heartDocRef = db.collection('messageHearts').doc(heartDocId);
      const msgRef = db.collection('communityMessages').doc(messageId);
      try{
        await db.runTransaction(async tx => {
          const heartSnap = await tx.get(heartDocRef);
          const msgSnap = await tx.get(msgRef);
          if(!msgSnap.exists) throw new Error('Message missing');
          let hearts = msgSnap.data().heartsCount || 0;
          if(!heartSnap.exists){
            tx.set(heartDocRef, { messageId, userId: uid, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            tx.update(msgRef, { heartsCount: hearts + 1 });
            userHeartsSet.add(messageId);
          } else {
            tx.delete(heartDocRef);
            tx.update(msgRef, { heartsCount: Math.max(0, hearts - 1) });
            userHeartsSet.delete(messageId);
          }
        });
      }catch(err){
        console.error('heart tx err',err);
        alert('Heart action failed');
      }
    }

    function startTypingLocal(){
      if(!currentProfile || !currentProfile.uid) return;
      if(localTyping){ clearTimeout(typingTimeout); typingTimeout = setTimeout(stopTyping,1700); return; }
      localTyping = true;
      db.collection('communityTyping').doc(currentProfile.uid).set({
        typing: true,
        uid: currentProfile.uid,
        name: currentProfile.name || '',
        photoUrl: currentProfile.photoUrl || '',
        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true }).catch(e => console.warn('typing set', e));
      typingTimeout = setTimeout(stopTyping, 1700);
    }
    function stopTyping(){
      if(!currentProfile || !currentProfile.uid) return;
      localTyping = false; clearTimeout(typingTimeout);
      db.collection('communityTyping').doc(currentProfile.uid).set({
        typing: false,
        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true }).catch(e => console.warn('typing clear', e));
    }

    function setupTypingListener(){
      if(typeof unsubscribeTyping === 'function') unsubscribeTyping();
      unsubscribeTyping = db.collection('communityTyping').where('typing','==',true).onSnapshot(snap => {
        const typingUsers = [];
        snap.forEach(doc => {
          if(currentProfile && doc.id === currentProfile.uid) return;
          const d = doc.data();
          if(d && d.name) typingUsers.push(d.name);
        });
        if(!typingUsers.length) typingIndicator.textContent = '';
        else if(typingUsers.length === 1) typingIndicator.textContent = `${typingUsers[0]} is typingâ€¦`;
        else if(typingUsers.length === 2) typingIndicator.textContent = `${typingUsers[0]} and ${typingUsers[1]} are typingâ€¦`;
        else typingIndicator.textContent = `${typingUsers[0]} and ${typingUsers.length - 1} others are typingâ€¦`;
      }, err => console.warn('typing listener err', err));
    }

    function setReplyTo(obj){
      replyTo = obj;
      replyPreviewWrap.style.display = 'block';
      replyPreviewWrap.setAttribute('aria-hidden', 'false');
      replyPreview.innerHTML = `<strong style="color:#cbe3ff">${escapeHtml(obj.authorName||'')}</strong>: ${escapeHtml(obj.snippet||'')} &nbsp; <button class="btn-ghost" id="cancel-reply">Cancel</button>`;
      document.getElementById('cancel-reply').addEventListener('click', clearReply);
      messageInput.focus();
    }
    function clearReply(){ replyTo = null; replyPreviewWrap.style.display = 'none'; replyPreviewWrap.setAttribute('aria-hidden', 'true'); replyPreview.innerHTML = ''; }

    function setupRealtimeListener(){
      if(typeof unsubscribeMessages === 'function') unsubscribeMessages();
      messagesArea.innerHTML = '<div style="text-align:center;color:#a0a0d0;padding:2rem">Loading chat...</div>';
      const q = db.collection('communityMessages').where('visibility','==',true).orderBy('timestamp','asc').limit(500);
      unsubscribeMessages = q.onSnapshot(snapshot => {
        renderMessagesFromSnapshot(snapshot);
      }, err => {
        console.error('messages listener err', err);
        messagesArea.innerHTML = `<div style="text-align:center;color:#f88;padding:2rem">Failed to load: ${escapeHtml(err.message || 'unknown')}</div>`;
        hideLoadingOverlay();
      });
    }

    async function loadUserHearts(uid){
      userHeartsSet.clear();
      try{
        const snaps = await db.collection('messageHearts').where('userId','==',uid).get();
        snaps.forEach(d=> userHeartsSet.add(d.data().messageId));
      }catch(e){ console.warn('load hearts err',e); }
    }

    auth.onAuthStateChanged(async (user) => {
      if(!user){
        showLoadingOverlay('Redirecting to sign upâ€¦', 'You need an account to use the community chat');
        setTimeout(()=> window.location.href = '/teamgalaxy/legal/sign_up.html', 900);
        return;
      }
      try{
        const initial = (user.displayName || user.email || 'U').charAt(0).toUpperCase();

        // try to load private doc (may contain legacy slug, display overrides, spamControl)
        let pd = {};
        try {
          const privateDoc = await db.collection('usersPrivate').doc(user.uid).get();
          if(privateDoc.exists) pd = privateDoc.data() || {};
        } catch(e) {
          console.warn('private doc fetch err', e);
        }

        // restore spamControl state if present
        if (pd.spamControl) {
          const sc = pd.spamControl || {};
          spamState.violationCount = sc.violationCount || 0;
          spamState.lastMessageText = sc.lastMessageText || '';
          spamState.lastMessageRepeatCount = sc.lastMessageRepeatCount || 0;
          if (sc.muteUntil) {
            try {
              if (sc.muteUntil.toDate) {
                spamState.muteUntil = sc.muteUntil.toDate().getTime();
              } else if (typeof sc.muteUntil === 'number') {
                spamState.muteUntil = sc.muteUntil;
              }
            } catch(e) {
              spamState.muteUntil = 0;
            }
          }
        }

        // preserve legacy slug if present but DO NOT use it for message routing
        const legacySlug = pd.slug || null;

        // optionally fetch nicer display values from publicProfiles if legacy slug exists
        let displayName = user.displayName || '';
        let displayPhoto = user.photoURL || '';
        if(legacySlug){
          try {
            const pub = await db.collection('publicProfiles').doc(legacySlug).get();
            if(pub.exists){
              const pubd = pub.data() || {};
              displayName = pubd.name || displayName;
              displayPhoto = pubd.profilePhotoUrl || displayPhoto;
            }
          } catch(e){
            console.warn('publicProfiles fetch err', e);
          }
        }

        // overrides from private doc
        displayName = pd.name || pd.displayName || displayName || (user.email ? user.email.split('@')[0] : 'Anonymous');
        displayPhoto = pd.profilePhotoUrl || pd.photoUrl || displayPhoto || '';

        currentProfile = {
          uid: user.uid,
          name: displayName,
          photoUrl: displayPhoto,
          slug: legacySlug // stored but not used for routing
        };

        // render header avatar
        headerAvatar.innerHTML = '';
        if(currentProfile.photoUrl){
          const img = document.createElement('img'); img.src = currentProfile.photoUrl; img.alt = currentProfile.name || 'Profile'; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover';
          img.onerror = ()=> headerAvatar.textContent = (currentProfile.name || initial).charAt(0);
          headerAvatar.appendChild(img);
        } else headerAvatar.textContent = (currentProfile.name || initial).charAt(0);
      }catch(e){
        console.warn('profile fetch err', e);
        currentProfile = { uid: user.uid, name: user.displayName || 'Anonymous', photoUrl: user.photoURL || '' };
        headerAvatar.textContent = (user.displayName||'U').charAt(0);
      }

      messageInput.disabled = false;
      sendButton.disabled = false;
      await loadUserHearts(user.uid);
      setupRealtimeListener();
      setupTypingListener();
      hideLoadingOverlay();
    });

    messageInput.addEventListener('input', ()=> startTypingLocal());
    messageInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); }});
    sendButton.addEventListener('click', ()=> sendMessage());

    window.addEventListener('beforeunload', ()=> {
      try{
        if(currentProfile && currentProfile.uid) db.collection('communityTyping').doc(currentProfile.uid).set({ typing:false, lastSeen: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
      }catch(e){}
      if(typeof unsubscribeMessages === 'function') unsubscribeMessages();
      if(typeof unsubscribeTyping === 'function') unsubscribeTyping();
    });
  </script>
</body>
</html>